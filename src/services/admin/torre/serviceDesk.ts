/**
 * ────────────────────────────────────
 * TORRE DE CONTROLE — SERVICE DESK
 * ────────────────────────────────────
 * Gestão centralizada de tickets e detratores
 * 
 * REGRA OBRIGATÓRIA: Todo feedback DETRATOR gera ticket automaticamente
 */

import { getFirestore } from 'firebase-admin/firestore';
import type { ServiceDeskSummary, Ticket, TicketStatus, TicketPriority, TicketSource } from './types';

/**
 * Gera ticket automaticamente a partir de feedback detrator
 */
async function autoGenerateDetractorTicket(
  feedback: any,
  db: FirebaseFirestore.Firestore
): Promise<void> {
  try {
    const ticketData = {
      userId: feedback.userId,
      userName: feedback.userName || 'Usuário',
      userType: feedback.userType || 'family',
      source: 'detractor' as TicketSource,
      priority: 'high' as TicketPriority,
      status: 'open' as TicketStatus,
      subject: `Detrator NPS: ${feedback.score}/10`,
      description: feedback.comment || 'Sem comentário adicional',
      npsScore: feedback.score,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    await db.collection('tickets').add(ticketData);
    console.log(`[ServiceDesk] Ticket automático criado para detrator ${feedback.userId}`);
  } catch (error) {
    console.error('[ServiceDesk] Erro ao criar ticket de detrator:', error);
  }
}

/**
 * Busca todos os tickets ativos
 */
async function getActiveTickets(db: FirebaseFirestore.Firestore): Promise<Ticket[]> {
  try {
    const ticketsSnap = await db
      .collection('tickets')
      .where('status', 'in', ['open', 'in_progress', 'waiting_user'])
      .orderBy('createdAt', 'desc')
      .limit(100)
      .get();

    return ticketsSnap.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        userId: data.userId,
        userName: data.userName,
        userType: data.userType,
        source: data.source,
        priority: data.priority,
        status: data.status,
        subject: data.subject,
        description: data.description,
        npsScore: data.npsScore,
        createdAt: data.createdAt?.toDate() || new Date(),
        updatedAt: data.updatedAt?.toDate() || new Date(),
        firstResponseAt: data.firstResponseAt?.toDate(),
        resolvedAt: data.resolvedAt?.toDate(),
        assignedTo: data.assignedTo,
      } as Ticket;
    });
  } catch (error) {
    console.error('[ServiceDesk] Erro ao buscar tickets ativos:', error);
    return [];
  }
}

/**
 * Calcula métricas do Service Desk
 */
export async function getServiceDeskSummary(): Promise<ServiceDeskSummary> {
  const db = getFirestore();

  try {
    // 1. Buscar detratores recentes e garantir que têm tickets
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const detractorsSnap = await db
      .collection('feedbacks')
      .where('score', '<=', 6)
      .where('createdAt', '>=', thirtyDaysAgo)
      .get();

    // Criar tickets automaticamente para detratores sem ticket
    for (const doc of detractorsSnap.docs) {
      const feedback = doc.data();
      const existingTicket = await db
        .collection('tickets')
        .where('userId', '==', feedback.userId)
        .where('source', '==', 'detractor')
        .where('npsScore', '==', feedback.score)
        .limit(1)
        .get();

      if (existingTicket.empty) {
        await autoGenerateDetractorTicket(feedback, db);
      }
    }

    // 2. Buscar todos os tickets ativos
    const activeTickets = await getActiveTickets(db);

    // 3. Calcular métricas
    const totalOpen = activeTickets.filter(t => t.status === 'open' || t.status === 'in_progress').length;
    const totalCritical = activeTickets.filter(t => t.priority === 'urgent' || t.priority === 'high').length;
    const detractors = activeTickets.filter(t => t.source === 'detractor').length;

    // Tickets >24h sem resposta
    const oneDayAgo = new Date();
    oneDayAgo.setDate(oneDayAgo.getDate() - 1);
    const ticketsOver24h = activeTickets.filter(t => 
      t.createdAt < oneDayAgo && !t.firstResponseAt
    ).length;

    // Tempo médio de primeira resposta (em minutos)
    const ticketsWithResponse = activeTickets.filter(t => t.firstResponseAt);
    const avgResponseTimeMinutes = ticketsWithResponse.length > 0
      ? ticketsWithResponse.reduce((sum, t) => {
          const responseTime = (t.firstResponseAt!.getTime() - t.createdAt.getTime()) / (1000 * 60);
          return sum + responseTime;
        }, 0) / ticketsWithResponse.length
      : 0;

    // Agrupamento por fonte
    const bySource: Record<TicketSource, number> = {
      detractor: 0,
      complaint: 0,
      bug: 0,
      question: 0,
      feature_request: 0,
    };
    activeTickets.forEach(t => {
      bySource[t.source] = (bySource[t.source] || 0) + 1;
    });

    // Agrupamento por prioridade
    const byPriority: Record<TicketPriority, number> = {
      low: 0,
      normal: 0,
      high: 0,
      urgent: 0,
    };
    activeTickets.forEach(t => {
      byPriority[t.priority] = (byPriority[t.priority] || 0) + 1;
    });

    return {
      totalOpen,
      totalCritical,
      detractors,
      avgResponseTimeMinutes: Math.round(avgResponseTimeMinutes),
      ticketsOver24h,
      bySource,
      byPriority,
      recentTickets: activeTickets.slice(0, 10),
    };
  } catch (error) {
    console.error('[ServiceDesk] Erro ao gerar resumo:', error);
    return {
      totalOpen: 0,
      totalCritical: 0,
      detractors: 0,
      avgResponseTimeMinutes: 0,
      ticketsOver24h: 0,
      bySource: {
        detractor: 0,
        complaint: 0,
        bug: 0,
        question: 0,
        feature_request: 0,
      },
      byPriority: {
        low: 0,
        normal: 0,
        high: 0,
        urgent: 0,
      },
      recentTickets: [],
    };
  }
}
